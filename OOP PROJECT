import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Random;
import javax.swing.*;

public class PacMan extends JPanel implements ActionListener, KeyListener {
    private String[][] levelMaps = {
        {  // Level 1 - Workshop (Easy)
            "XXXXXXXXXXXXXXXXXXX",
            "X   A     X     B X",
            "X XX XXX  X   XX  X",
            "X       R         X",
            "X XX X XXXXX X XX X",
            "X  L X   S   X L  X",
            "XXXX XXXX XXXX XXXX",
            "X    X   A   X    X",
            "XXXX   XXXXX   XXXX",
            "X     P   B   K   X",
            "XXXX X XXXXX X XXXX",
            "X    X       X    X",
            "XXXX X XXXXX X XXXX",
            "X        X        X",
            "X XX XXX X XXX XX X",
            "X  X     E     X  X",
            "XX X X XXXXX X X XX",
            "X    X   X   X    X",
            "X XXXXXX X XXXXXX X",
            "X       A B       X",
            "XXXXXXXXXXXXXXXXXXX" 
        },
        {  // Level 2 - Chemical Storage (Intermediate)
            "XXXXXXXXXXXXXXXXXXX",
            "X A         L   A X",
            "X XXXXX X XXXXX X X",
            "X      RX    S    X",
            "X XXX XXXXXXX XXX X",
            "X X       B       X",
            "X X XXXXXXXXXXXXX X",
            "X X  L  X X   A   X",
            "X XXXXXXX X XXXXXXX",
            "X       P         X",
            "XXXXXXX X XXXXXXXXX",
            "X    K  X    L    X",
            "X XXXXXXXXXXXXX X X",
            "X  A    X       X X",
            "XXXXXXX X XXXXXXX X",
            "X       X    B    X",
            "X XXXXX X XXXXX XXX",
            "X   L   X         X",
            "XXXXXXX X XXXXXXXXX",
            "X   A  R     E    X",
            "XXXXXXXXXXXXXXXXXXX"
        },
        {  // Level 3 - Server Room (Advanced)
            "XXXXXXXXXXXXXXXXXXX",
            "XAAA X  L  X AAA XX",
            "XAAA X XXX X AAA XX",
            "X    X  R  X  B  XX",
            "XXXX X X X X XXXXXXX",
            "X      X X    K   X",
            "X XXXXXXXXXXXXX X X",
            "X   L  XXX    A   X",
            "XXXX X  S  X XXXXXX",
            "X    X XXX X      X",
            "X XXXX P XXXX X X X",
            "X    X XXX X      X",
            "XXXX X  B  X XXXXXX",
            "X      XXX        X",
            "X XXXXXXXXXXXXX X X",
            "X      X X    L   X",
            "XXXX X X X X XXXXXX",
            "X    X  A  X  R  XX",
            "XAAA X XXX X AAA XX",
            "XAA     E     KAA X",
            "XXXXXXXXXXXXXXXXXXX"
        },
        {  // Level 4 - Reactor Core (Hardest)
            "XXXXXXXXXXXXXXXXXXX",
            "X  AAA  X X  AAA  X",
            "X XXXXX X X XXXXX X",
            "X   L       B     X",
            "XXXXX XXXXXXX XXXXX",
            "X  A  X  R  X  A  X",
            "X XXX X XXX X XXX X",
            "X       K    L    X",
            "X XXX XXXXXXX XXX X",
            "X        P        X",
            "X XXX X XXX X XXX X",
            "X  B  X  S  X  B  X",
            "X XXXXXXXXXXXXX X X",
            "X    L    R   A   X",
            "XXXXX XXX XXX XXXXX",
            "X   X X  B  X X   X",
            "X X X X XXX X X X X",
            "X X       L       X",
            "X X XXXXXXXXXXX X X",
            "X   A        E    X",
            "XXXXXXXXXXXXXXXXXXX"
        }
    };

    enum HazardType {
        PATROL_BOT, ACID_POOL, ELECTRICAL_SPARK, LASER_BARRIER
    }
    
    enum ItemType {
        BATTERY, KEYCARD, SPEED_BOOST
    }
    
    class Item {
        int x, y, width, height;
        ItemType type;
        boolean collected = false;
        
        Item(ItemType type, int x, int y) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.width = tileSize/2;
            this.height = tileSize/2;
        }
        
        Color getColor() {
            switch(type) {
                case BATTERY: return Color.YELLOW;
                case KEYCARD: return Color.GREEN;
                case SPEED_BOOST: return Color.CYAN;
                default: return Color.WHITE;
            }
        }
        
        String getSymbol() {
            switch(type) {
                case BATTERY: return "B";
                case KEYCARD: return "K";
                case SPEED_BOOST: return "S";
                default: return "?";
            }
        }
    }

    class Hazard {
        int x, y, width, height;
        HazardType type;
        boolean active = true;
        int timer = 0;
        char direction = 'R';
        int velocityX = 0, velocityY = 0;
        boolean chasing = false;
        int chaseTimer = 0;
        int detectionRadius = tileSize * 3;
        
        Hazard(HazardType type, int x, int y) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.width = tileSize;
            this.height = tileSize;
            
            if (type == HazardType.PATROL_BOT) {
                updateVelocity();
            }
        }
        
        void updateVelocity() {
            int speed = tileSize/6;
            switch(direction) {
                case 'U': velocityX = 0; velocityY = -speed; break;
                case 'D': velocityX = 0; velocityY = speed; break;
                case 'L': velocityX = -speed; velocityY = 0; break;
                case 'R': velocityX = speed; velocityY = 0; break;
            }
        }
        
        void update() {
            timer++;
            
            switch(type) {
                case ELECTRICAL_SPARK:
                    // Flicker on/off
                    active = (timer % 40) < 20;
                    break;
                    
                case LASER_BARRIER:
                    // Activate/deactivate in intervals
                    active = (timer % 120) < 60;
                    break;
                    
                case PATROL_BOT:
                    // Check for player detection
                    double distance = Math.sqrt(Math.pow(x - robot.x, 2) + Math.pow(y - robot.y, 2));
                    if (distance <= detectionRadius && !chasing) {
                        chasing = true;
                        chaseTimer = 200; // Chase for 10 seconds
                    }
                    
                    if (chasing) {
                        chaseTimer--;
                        if (chaseTimer <= 0) {
                            chasing = false;
                        } else {
                            // Move towards player
                            int dx = robot.x - x;
                            int dy = robot.y - y;
                            if (Math.abs(dx) > Math.abs(dy)) {
                                direction = dx > 0 ? 'R' : 'L';
                            } else {
                                direction = dy > 0 ? 'D' : 'U';
                            }
                        }
                    } else {
                        // Random movement
                        if (timer % 60 == 0) {
                            direction = directions[random.nextInt(4)];
                        }
                    }
                    
                    updateVelocity();
                    x += velocityX;
                    y += velocityY;
                    
                    // Check wall collisions
                    for (Block wall : walls) {
                        if (collision(this, wall)) {
                            x -= velocityX;
                            y -= velocityY;
                            direction = directions[random.nextInt(4)];
                            updateVelocity();
                            break;
                        }
                    }
                    break;
                    
                default:
                    break;
            }
        }
        
        boolean collision(Hazard h, Block b) {
            return h.x < b.x + b.width &&
                   h.x + h.width > b.x &&
                   h.y < b.y + b.height &&
                   h.y + h.height > b.y;
        }
    }

    class Robot {
        int x, y, width, height;
        int velocityX = 0, velocityY = 0;
        char direction = 'R';
        Image image;
        
        Robot(int x, int y) {
            this.x = x;
            this.y = y;
            this.width = tileSize;
            this.height = tileSize;
        }
        
        void updateDirection(char newDirection) {
            this.direction = newDirection;
            updateVelocity();
            
            int newX = x + velocityX;
            int newY = y + velocityY;
            
            // Check wall collision
            boolean canMove = true;
            for (Block wall : walls) {
                if (newX < wall.x + wall.width && newX + width > wall.x &&
                    newY < wall.y + wall.height && newY + height > wall.y) {
                    canMove = false;
                    break;
                }
            }
            
            if (canMove) {
                x = newX;
                y = newY;
            }
        }
        
        void updateVelocity() {
            int speed = tileSize/4;
            if (speedBoostActive) {
                speed = (int)(speed * 1.5);
            }
            
            switch(direction) {
                case 'U': velocityX = 0; velocityY = -speed; break;
                case 'D': velocityX = 0; velocityY = speed; break;
                case 'L': velocityX = -speed; velocityY = 0; break;
                case 'R': velocityX = speed; velocityY = 0; break;
            }
        }
    }

    private int rowCount = 21;
    private int columnCount = 19;
    private int tileSize = 32;
    private int boardWidth = columnCount * tileSize;
    private int boardHeight = rowCount * tileSize;

    private int currentLevel = 0;
    private final int MAX_LEVEL = 4;
    private boolean levelTransition = false;
    private int transitionCountdown = 0;
    
    // Memory mechanic
    private boolean previewMode = true;
    private int previewTimer = 0;
    private int[] previewDurations = {200, 150, 100, 50}; // Decreasing preview times
    
    // Battery system
    private int batteryLevel = 100;
    private int maxBattery = 100;
    private final int BATTERY_DRAIN_RATE = 1; // Every 2 seconds
    private int batteryDrainTimer = 0;
    private final int VISION_RADIUS = 64; // Flashlight radius
    
    // Game state
    private boolean gameStarted = false;
    private boolean showInstructions = false;
    private boolean gamePaused = false;
    
    // Resources
    private boolean hasKeycard = false;
    private boolean speedBoostActive = false;
    private int speedBoostDuration = 0;
    
    private HashSet<Block> walls;
    private HashSet<Item> items;
    private HashSet<Hazard> hazards;
    private Robot robot;
    private Block exit;

    Timer gameLoop;
    Timer previewTimer_obj;
    char[] directions = {'U', 'D', 'L', 'R'};
    Random random = new Random();
    int score = 0;
    boolean gameOver = false;
    boolean levelComplete = false;
    
    // Visual effects
    private boolean blinkState = false;
    private int blinkTimer = 0;

    PacMan() {
        setPreferredSize(new Dimension(boardWidth, boardHeight));
        setBackground(Color.BLACK);
        addKeyListener(this);
        setFocusable(true);

        showMainMenu();
    }
    
    private void showMainMenu() {
        gameStarted = false;
        repaint();
    }
    
    private void showInstructions() {
        showInstructions = true;
        repaint();
    }
    
    private void startGame() {
        gameStarted = true;
        showInstructions = false;
        currentLevel = 0;
        score = 0;
        batteryLevel = maxBattery;
        hasKeycard = false;
        gameOver = false;
        levelComplete = false;
        
        loadLevel();
        startPreview();
        
        gameLoop = new Timer(50, this);
        gameLoop.start();
    }
    
    private void startPreview() {
        previewMode = true;
        previewTimer = previewDurations[Math.min(currentLevel, previewDurations.length - 1)];
        
        previewTimer_obj = new Timer(50, e -> {
            previewTimer--;
            if (previewTimer <= 0) {
                previewMode = false;
                previewTimer_obj.stop();
            }
            repaint();
        });
        previewTimer_obj.start();
    }

    public void loadLevel() {
        walls = new HashSet<>();
        items = new HashSet<>();
        hazards = new HashSet<>();

        for (int r = 0; r < rowCount; r++) {
            String row = levelMaps[currentLevel][r];
            for (int c = 0; c < columnCount; c++) {
                char tile = row.charAt(c);
                int x = c * tileSize;
                int y = r * tileSize;

                switch(tile) {
                    case 'X':
                        walls.add(new Block(null, x, y, tileSize, tileSize));
                        break;
                    case 'P':
                        robot = new Robot(x, y);
                        break;
                    case 'E':
                        exit = new Block(null, x, y, tileSize, tileSize);
                        break;
                    case 'A':
                        hazards.add(new Hazard(HazardType.ACID_POOL, x, y));
                        break;
                    case 'S':
                        hazards.add(new Hazard(HazardType.ELECTRICAL_SPARK, x, y));
                        break;
                    case 'L':
                        hazards.add(new Hazard(HazardType.LASER_BARRIER, x, y));
                        break;
                    case 'R':
                        hazards.add(new Hazard(HazardType.PATROL_BOT, x, y));
                        break;
                    case 'B':
                        items.add(new Item(ItemType.BATTERY, x, y));
                        break;
                    case 'K':
                        items.add(new Item(ItemType.KEYCARD, x, y));
                        break;
                    default:
                        break;
                }
            }
        }
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D)g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        if (!gameStarted) {
            drawMainMenu(g2);
            return;
        }
        
        if (showInstructions) {
            drawInstructions(g2);
            return;
        }
        
        // Update blinking effect
        blinkTimer++;
        if (blinkTimer >= 10) {
            blinkState = !blinkState;
            blinkTimer = 0;
        }
        
        // Dark factory background
        g2.setColor(new Color(20, 20, 30));
        g2.fillRect(0, 0, boardWidth, boardHeight);
        
        // Draw game elements
        if (previewMode) {
            // Full visibility during preview
            drawAllElements(g2, false);
            
            // Preview countdown
            g2.setColor(new Color(255, 255, 0, 200));
            g2.setFont(new Font("Arial", Font.BOLD, 24));
            String previewText = "Memory Preview: " + (previewTimer / 20 + 1) + "s";
            int textWidth = g2.getFontMetrics().stringWidth(previewText);
            g2.fillRoundRect((boardWidth - textWidth) / 2 - 10, 50, textWidth + 20, 35, 10, 10);
            g2.setColor(Color.BLACK);
            g2.drawString(previewText, (boardWidth - textWidth) / 2, 75);
        } else {
            // Limited visibility mode
            drawAllElements(g2, true);
        }
        
        drawHUD(g2);
        
        if (levelComplete) {
            drawLevelComplete(g2);
        }
        
        if (gameOver) {
            drawGameOver(g2);
        }
        
        if (gamePaused) {
            drawPauseMenu(g2);
        }
    }
    
    private void drawMainMenu(Graphics2D g2) {
        // Background
        g2.setColor(new Color(20, 20, 30));
        g2.fillRect(0, 0, boardWidth, boardHeight);
        
        // Title
        g2.setColor(new Color(255, 100, 0));
        g2.setFont(new Font("Arial", Font.BOLD, 36));
        String title = "FACTORY OUTAGE";
        int titleWidth = g2.getFontMetrics().stringWidth(title);
        g2.drawString(title, (boardWidth - titleWidth) / 2, 150);
        
        g2.setFont(new Font("Arial", Font.ITALIC, 24));
        String subtitle = "Memory Escape";
        int subtitleWidth = g2.getFontMetrics().stringWidth(subtitle);
        g2.drawString(subtitle, (boardWidth - subtitleWidth) / 2, 180);
        
        // Menu options
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.PLAIN, 18));
        g2.drawString("Press SPACE to Start Game", (boardWidth - 200) / 2, 250);
        g2.drawString("Press I for Instructions", (boardWidth - 200) / 2, 280);
        g2.drawString("Press ESC to Exit", (boardWidth - 200) / 2, 310);
        
        // Robot icon
        g2.setColor(new Color(100, 150, 255));
        g2.fillRoundRect(boardWidth/2 - 20, 350, 40, 40, 10, 10);
        g2.setColor(Color.WHITE);
        g2.fillOval(boardWidth/2 - 15, 355, 10, 10);
        g2.fillOval(boardWidth/2 + 5, 355, 10, 10);
    }
    
    private void drawInstructions(Graphics2D g2) {
        g2.setColor(new Color(20, 20, 30));
        g2.fillRect(0, 0, boardWidth, boardHeight);
        
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.BOLD, 24));
        g2.drawString("INSTRUCTIONS", 50, 50);
        
        g2.setFont(new Font("Arial", Font.PLAIN, 16));
        String[] instructions = {
            "• Navigate the robot through dark factory floors",
            "• Memory Preview: Map shown briefly at start",
            "• Use arrow keys to move the robot",
            "• Avoid hazards: Acid (Red), Sparks (Yellow), Lasers (Purple)",
            "• Collect batteries (B) to maintain power",
            "• Find keycards (K) to unlock exit doors",
            "• Beware of patrol bots (they chase you!)",
            "• Reach the exit (E) to complete each level",
            "",
            "Press SPACE to start playing",
            "Press ESC to return to main menu"
        };
        
        for (int i = 0; i < instructions.length; i++) {
            g2.drawString(instructions[i], 50, 90 + i * 25);
        }
    }
    
    private void drawAllElements(Graphics2D g2, boolean limitedVision) {
        // Create vision mask if limited vision
        Shape originalClip = null;
        if (limitedVision && batteryLevel > 0) {
            originalClip = g2.getClip();
            int visionRadius = (int)(VISION_RADIUS * (batteryLevel / 100.0));
            g2.setClip(new java.awt.geom.Ellipse2D.Float(
                robot.x + robot.width/2 - visionRadius,
                robot.y + robot.height/2 - visionRadius,
                visionRadius * 2,
                visionRadius * 2
            ));
        }
        
        // Draw walls
        g2.setColor(new Color(80, 80, 90));
        for (Block wall : walls) {
            g2.fillRect(wall.x, wall.y, wall.width, wall.height);
            g2.setColor(new Color(120, 120, 130));
            g2.drawRect(wall.x, wall.y, wall.width - 1, wall.height - 1);
            g2.setColor(new Color(80, 80, 90));
        }
        
        // Draw exit
        g2.setColor(hasKeycard ? Color.GREEN : Color.RED);
        g2.fillRect(exit.x + 4, exit.y + 4, exit.width - 8, exit.height - 8);
        g2.setColor(Color.WHITE);
        g2.drawString("EXIT", exit.x + 2, exit.y + 20);
        
        // Draw items
        for (Item item : items) {
            if (!item.collected && blinkState) {
                g2.setColor(item.getColor());
                g2.fillOval(item.x + tileSize/4, item.y + tileSize/4, item.width, item.height);
                g2.setColor(Color.WHITE);
                g2.setFont(new Font("Arial", Font.BOLD, 12));
                g2.drawString(item.getSymbol(), item.x + tileSize/2 - 4, item.y + tileSize/2 + 4);
            }
        }
        
        // Draw hazards
        for (Hazard hazard : hazards) {
            switch(hazard.type) {
                case ACID_POOL:
                    g2.setColor(new Color(200, 50, 50, 180));
                    g2.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                    g2.setColor(new Color(255, 100, 100));
                    g2.drawRect(hazard.x, hazard.y, hazard.width - 1, hazard.height - 1);
                    break;
                    
                case ELECTRICAL_SPARK:
                    if (hazard.active) {
                        g2.setColor(new Color(255, 255, 0, 200));
                        g2.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                        // Draw spark effects
                        g2.setStroke(new BasicStroke(3));
                        g2.setColor(Color.YELLOW);
                        g2.drawLine(hazard.x, hazard.y, hazard.x + hazard.width, hazard.y + hazard.height);
                        g2.drawLine(hazard.x + hazard.width, hazard.y, hazard.x, hazard.y + hazard.height);
                        g2.setStroke(new BasicStroke(1));
                    }
                    break;
                    
                case LASER_BARRIER:
                    if (hazard.active) {
                        g2.setColor(new Color(255, 0, 255, 150));
                        g2.fillRect(hazard.x, hazard.y, hazard.width, hazard.height);
                        g2.setStroke(new BasicStroke(2));
                        g2.setColor(Color.MAGENTA);
                        g2.drawLine(hazard.x, hazard.y + hazard.height/2, 
                                   hazard.x + hazard.width, hazard.y + hazard.height/2);
                        g2.setStroke(new BasicStroke(1));
                    }
                    break;
                    
                case PATROL_BOT:
                    // Draw detection radius if chasing
                    if (hazard.chasing) {
                        g2.setColor(new Color(255, 0, 0, 50));
                        g2.fillOval(hazard.x - hazard.detectionRadius/2, 
                                   hazard.y - hazard.detectionRadius/2,
                                   hazard.detectionRadius, hazard.detectionRadius);
                    }
                    
                    // Draw patrol bot
                    g2.setColor(new Color(150, 50, 50));
                    g2.fillRoundRect(hazard.x + 2, hazard.y + 2, hazard.width - 4, hazard.height - 4, 5, 5);
                    g2.setColor(hazard.chasing ? Color.RED : Color.ORANGE);
                    g2.fillOval(hazard.x + 8, hazard.y + 8, 8, 8);
                    g2.fillOval(hazard.x + 16, hazard.y + 8, 8, 8);
                    break;
            }
        }
        
        // Draw robot
        g2.setColor(new Color(100, 150, 255));
        g2.fillRoundRect(robot.x + 2, robot.y + 2, robot.width - 4, robot.height - 4, 8, 8);
        g2.setColor(Color.WHITE);
        g2.fillOval(robot.x + 6, robot.y + 6, 8, 8);
        g2.fillOval(robot.x + 18, robot.y + 6, 8, 8);
        
        // Speed boost effect
        if (speedBoostActive) {
            g2.setColor(new Color(0, 255, 255, 100));
            g2.fillOval(robot.x - 4, robot.y - 4, robot.width + 8, robot.height + 8);
        }
        
        // Restore original clip
        if (limitedVision && originalClip != null) {
            g2.setClip(originalClip);
        }
    }
    
    private void drawHUD(Graphics2D g2) {
        // HUD Background
        g2.setColor(new Color(0, 0, 0, 180));
        g2.fillRoundRect(10, 10, 350, 60, 15, 15);
        
        // Level and score
        g2.setFont(new Font("Arial", Font.BOLD, 16));
        g2.setColor(Color.WHITE);
        g2.drawString("Level: " + (currentLevel + 1) + "/4", 20, 30);
        g2.drawString("Score: " + score, 20, 50);
        
        // Battery level
        g2.drawString("Battery:", 150, 30);
        g2.setColor(batteryLevel > 20 ? Color.GREEN : Color.RED);
        g2.fillRect(220, 20, (int)(batteryLevel * 1.2), 12);
        g2.setColor(Color.WHITE);
        g2.drawRect(220, 20, 120, 12);
        g2.drawString(batteryLevel + "%", 220, 50);
        
        // Keycard status
        if (hasKeycard) {
            g2.setColor(Color.GREEN);
            g2.drawString("KEYCARD ✓", 280, 50);
        }
        
        // Active effects
        if (speedBoostActive) {
            g2.setColor(Color.CYAN);
            g2.drawString("SPEED: " + (speedBoostDuration / 20) + "s", 150, 50);
        }
    }
    
    private void drawLevelComplete(Graphics2D g2) {
        g2.setColor(new Color(0, 0, 0, 150));
        g2.fillRect(0, 0, boardWidth, boardHeight);
        
        g2.setColor(Color.GREEN);
        g2.setFont(new Font("Arial", Font.BOLD, 36));
        String text = "LEVEL COMPLETE!";
        int textWidth = g2.getFontMetrics().stringWidth(text);
        g2.drawString(text, (boardWidth - textWidth) / 2, boardHeight / 2);
        
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.PLAIN, 18));
        String continueText = "Press SPACE to continue";
        int continueWidth = g2.getFontMetrics().stringWidth(continueText);
        g2.drawString(continueText, (boardWidth - continueWidth) / 2, boardHeight / 2 + 40);
    }
    
    private void drawGameOver(Graphics2D g2) {
        g2.setColor(new Color(0, 0, 0, 180));
        g2.fillRect(0, 0, boardWidth, boardHeight);
        
        String message = (currentLevel >= MAX_LEVEL - 1) ? "FACTORY ESCAPED!" : "SYSTEM FAILURE";
        Color textColor = (currentLevel >= MAX_LEVEL - 1) ? Color.GREEN : Color.RED;
        
        g2.setColor(textColor);
        g2.setFont(new Font("Arial", Font.BOLD, 36));
        int textWidth = g2.getFontMetrics().stringWidth(message);
        g2.drawString(message, (boardWidth - textWidth) / 2, boardHeight / 2);
        
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.PLAIN, 18));
        g2.drawString("Final Score: " + score, (boardWidth - 120) / 2, boardHeight / 2 + 40);
        g2.drawString("Press R to Restart", (boardWidth - 150) / 2, boardHeight / 2 + 70);
    }
    
    private void drawPauseMenu(Graphics2D g2) {
        g2.setColor(new Color(0, 0, 0, 150));
        g2.fillRect(0, 0, boardWidth, boardHeight);
        
        g2.setColor(Color.YELLOW);
        g2.setFont(new Font("Arial", Font.BOLD, 36));
        String text = "PAUSED";
        int textWidth = g2.getFontMetrics().stringWidth(text);
        g2.drawString(text, (boardWidth - textWidth) / 2, boardHeight / 2);
        
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.PLAIN, 18));
        g2.drawString("Press P to Resume", (boardWidth - 150) / 2, boardHeight / 2 + 40);
    }

    public void update() {
        if (gamePaused || gameOver || levelComplete || !gameStarted) return;
        
        // Update battery drain
        batteryDrainTimer++;
        if (batteryDrainTimer >= 40 && !previewMode) { // Every 2 seconds
            batteryLevel = Math.max(0, batteryLevel - BATTERY_DRAIN_RATE);
            batteryDrainTimer = 0;
            
            if (batteryLevel <= 0) {
                gameOver = true;
                return;
            }
        }
        
        // Update speed boost
        if (speedBoostActive) {
            speedBoostDuration--;
            if (speedBoostDuration <= 0) {
                speedBoostActive = false;
            }
        }
        
        // Update hazards
        for (Hazard hazard : hazards) {
            hazard.update();
            
            // Check collision with robot
            if (collision(robot, hazard) && hazard.active) {
                if (hazard.type == HazardType.PATROL_BOT || 
                    hazard.type == HazardType.ACID_POOL ||
                    (hazard.type == HazardType.ELECTRICAL_SPARK && hazard.active) ||
                    (hazard.type == HazardType.LASER_BARRIER && hazard.active)) {
                    
                    batteryLevel = Math.max(0, batteryLevel - 20);
                    if (batteryLevel <= 0) {
                        gameOver = true;
                        return;
                    }
                    
                    // Push robot back
                    robot.x -= robot.velocityX * 2;
                    robot.y -= robot.velocityY * 2;
                }
            }
        }
        
        // Check item collection
        ArrayList<Item> itemsToRemove = new ArrayList<>();
        for (Item item : items) {
            if (!item.collected && collision(robot, item)) {
                item.collected = true;
                itemsToRemove.add(item);
                
                switch(item.type) {
                    case BATTERY:
                        batteryLevel = Math.min(maxBattery, batteryLevel + 30);
                        score += 50;
                        break;
                    case KEYCARD:
                        hasKeycard = true;
                        score += 100;
                        break;
                    case SPEED_BOOST:
                        speedBoostActive = true;
                        speedBoostDuration = 200; // 10 seconds
                        score += 75;
                        break;
                }
            }
        }
        items.removeAll(itemsToRemove);
        
        // Check exit collision
        if (collision(robot, exit)) {
            if (hasKeycard || currentLevel < 2) { // First two levels don't need keycard
                levelComplete = true;
                score += 200 + batteryLevel; // Bonus for remaining battery
            }
        }
    }
    
    private boolean collision(Robot r, Block b) {
        return r.x < b.x + b.width &&
               r.x + r.width > b.x &&
               r.y < b.y + b.height &&
               r.y + r.height > b.y;
    }
    
    private boolean collision(Robot r, Item i) {
        return r.x < i.x + i.width + tileSize/4 &&
               r.x + r.width > i.x + tileSize/4 &&
               r.y < i.y + i.height + tileSize/4 &&
               r.y + r.height > i.y + tileSize/4;
    }
    
    private boolean collision(Robot r, Hazard h) {
        return r.x < h.x + h.width &&
               r.x + r.width > h.x &&
               r.y < h.y + h.height &&
               r.y + r.height > h.y;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (gameStarted) {
            update();
        }
        repaint();
    }

    @Override
    public void keyTyped(KeyEvent e) {}

    @Override
    public void keyPressed(KeyEvent e) {}

    @Override
    public void keyReleased(KeyEvent e) {
        if (!gameStarted) {
            if (showInstructions) {
                if (e.getKeyCode() == KeyEvent.VK_SPACE) {
                    startGame();
                } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                    showInstructions = false;
                }
            } else {
                if (e.getKeyCode() == KeyEvent.VK_SPACE) {
                    startGame();
                } else if (e.getKeyCode() == KeyEvent.VK_I) {
                    showInstructions();
                } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                    System.exit(0);
                }
            }
            return;
        }
        
        if (levelComplete) {
            if (e.getKeyCode() == KeyEvent.VK_SPACE) {
                if (currentLevel < MAX_LEVEL - 1) {
                    currentLevel++;
                    levelComplete = false;
                    hasKeycard = false; // Reset keycard for new level
                    batteryLevel = maxBattery; // Restore battery
                    loadLevel();
                    startPreview();
                } else {
                    gameOver = true; // Won the game
                }
            }
            return;
        }
        
        if (gameOver) {
            if (e.getKeyCode() == KeyEvent.VK_R) {
                // Restart game
                currentLevel = 0;
                score = 0;
                batteryLevel = maxBattery;
                hasKeycard = false;
                speedBoostActive = false;
                gameOver = false;
                levelComplete = false;
                loadLevel();
                startPreview();
            } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                showMainMenu();
            }
            return;
        }
        
        if (e.getKeyCode() == KeyEvent.VK_P) {
            gamePaused = !gamePaused;
            if (gamePaused) {
                gameLoop.stop();
                if (previewTimer_obj != null) previewTimer_obj.stop();
            } else {
                gameLoop.start();
                if (previewMode && previewTimer_obj != null) previewTimer_obj.start();
            }
            return;
        }
        
        if (gamePaused) return;
        
        // Robot movement
        if (e.getKeyCode() == KeyEvent.VK_UP || e.getKeyCode() == KeyEvent.VK_W) {
            robot.updateDirection('U');
        }
        else if (e.getKeyCode() == KeyEvent.VK_DOWN || e.getKeyCode() == KeyEvent.VK_S) {
            robot.updateDirection('D');
        }
        else if (e.getKeyCode() == KeyEvent.VK_LEFT || e.getKeyCode() == KeyEvent.VK_A) {
            robot.updateDirection('L');
        }
        else if (e.getKeyCode() == KeyEvent.VK_RIGHT || e.getKeyCode() == KeyEvent.VK_D) {
            robot.updateDirection('R');
        }
    }

    // Helper class for walls and exit
    class Block {
        int x, y, width, height;
        Image image;
        
        Block(Image image, int x, int y, int width, int height) {
            this.image = image;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
    }

    public static void main(String[] args) {
        EventQueue.invokeLater(() -> {
            JFrame frame = new JFrame("Factory Outage: Memory Escape");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setResizable(false);
            
            PacMan game = new PacMan();
            frame.add(game);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
            
            game.requestFocusInWindow();
        });
    }
}
